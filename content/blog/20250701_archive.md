---
title: 'Archived Articles from Last Blog Site'
description: "Archived articles of unity game dev, my course project, rescued from my last blog site"
headline: 'Archived Articles'
date: '2025-07-01T12:00:00'
dateUpdated: ''
published: false
author: 'Xinyu'
tags: ['archive', 'unity', 'gamedev', 'programming', 'journey']
image: '/img/blog/archive-journey.webp'
socialImage:
    src: '/img/blog/archive-journey.webp'
    mime: 'webp'
    alt: 'Programming Journey Archive'
    width: 1200
    height: 630
readTime: 25
---

This blog includes all articles, together with an about page and an index page from my last. It is pulled from web archive and I didn't change a bit of its content. It is a cyber tomb to commemorate where I started as a programmer.

Back then it was during COVID, I was looking for jobs, mostly at game companies, while building my portfolio. I successfully landed my first job after six months as a backend engineer. Nowadays, I'm sort of repeating the same trajectory. If one sentence I could say to my past self, I would speak out: You are doing great, keep it up!

---

## Index
首页 关于Xinyu

数据分析/管理；机器学习；Programmer

### 文章分类
- Shaders (1)
- 技术 (4)
- 游戏 (3)
- 项目 (2)
- 默认分类 (2)

### Featured Articles

**[Unity] 摆脱Mecanim Animation里的"毛线团"：使用Enum来管理人物状态和动画系统**  
2020年10月2日 技术 0条评论 550次阅读 0人点赞 xinyu  
使用Enum来管理人物状态的好处有：完美替代 Unity Mecanim 的状态转换问题。避免Animator看起来像一团纠结在一起的毛线团 利用 [Flags] 的 Attribute可以方便的解决同时有两个或以上状…

**[ShaderLab] 让物体光面始终朝向观察者的Lighting Model**  
2020年8月12日 Shaders 0条评论 566次阅读 1人点赞 xinyu  
一个光面始终朝向观察者的Lighting Model

**[Unity] 什么是c#事件？如何用EventHandler或Action或UnityEvent实现它的功能？**  
2020年7月2日 技术 0条评论 612次阅读 0人点赞 xinyu  
"我要过去啦，开门！""请~" 微信公众号？个人邮箱？大字报？塔防里面通知每个小兵更改前进路线？下雨了每个NPC和花花草草要做什么？其实这些都可以称作事件（Events），它们都包含了观察者模型（Observer Des…

**[Unity自学] DevLog 1: Week 3&4, June 2020**  
2020年6月21日 默认分类 0条评论 576次阅读 0人点赞 xinyu  
June 20, 2020: 第一次接触到了Lighting system，光污染似的加了好多hhh 改进了一下操纵火箭的旋转和助推代码，加上加速度和减速度。如此一来操作手感好了一点。Unity建模能力十分差，甚至造不出…

**[Unity 2D Platform] 让人物移动拥有精确加速度和减速度的代码**  
2020年6月20日 技术 0条评论 499次阅读 0人点赞 xinyu  
GMTK总结的Celeste速度曲线（黄线） 在寻找和探索了许久之后我终于发现了接近完美的代码。在改进了这里的代码之后，以下的代码便可以指定人物的加速度和减速度以及最高速度，从而实现对速度曲线的控制。"It just w…

**[Unity自学] [Tile Vania: The Runner](/games/tile_vania) (2D platform)**  
2020年6月19日 游戏 0条评论 560次阅读 0人点赞 xinyu  
Tile Vania: The Runner 是一个快节奏的跑酷游戏。主角行动灵敏和迅速，他为了证明自己是最快的跑者踏上了试炼之路。欢迎在我的服务器上留下你们的名字和新的记录！ 做这款小游戏花了比预想的要就得多的时间。依…

**[Unity 2D Platform] 如何用Unity的原生物理系统实现更好的跳跃手感？**  
2020年6月17日 技术 0条评论 714次阅读 0人点赞 xinyu  
看到GMTK总结Celeste跳跃手感如何优秀以后，我突然意识到虽然几行代码可以实现跳跃效果，但是操作手感缺实在稀烂。于是我找到了这篇文章，然后用几种方法实现了它们（肯定也有更好的方法）。Unity原生的物理系统虽然很难…

**[课程项目] 深度学习： 由诊断结论生成正側面胸部CT/X光图像**  
2020年6月16日 项目 0条评论 516次阅读 0人点赞 xinyu  
摘要：这是一个深度学习的课程项目。我们用医生的X光胸片报告作为输入，最终输出高分辨率(256*256)的正側面X光胸片图。网络中多层conditional GAN的结构可以帮助我们依次获得更高分辨率的胸片图。结构主要包括…

**[课程项目] ML模型预测steam平台游戏销量**  
2020年6月11日 项目 0条评论 541次阅读 0人点赞 xinyu  
想知道一份游戏在steam上能卖出多少份么？想知道有哪几款游戏和我想要的一样么？点击这里查看我的课程项目介绍和部署到线上的模型吧。

**[Unity自学] 更复杂的程序+数值策划：[Glitch Garden](/games/glitch_garden)**  
2020年5月26日 游戏 0条评论 691次阅读 0人点赞 xinyu  
依旧是自己主程序+主策划，这次竟然有两关了！而且还有那激动人心的boss战！来用Gnomes筑起钢铁长城吧。虽然依旧是Udemy课程引领下做的项目，但我成功加进去了一些自己的心思，实现了关卡出怪的模块化和精确设计。毕竟哪…

---

## About
数据分析/管理；机器学习；Programmer

### 文章分类
- Shaders (1)
- 技术 (4)
- 游戏 (3)
- 项目 (2)
- 默认分类 (2)

### Xinyu是谁？
我是一名毕业后正在努力成为程序员的人。

UCSD2020届的国际关系硕士。

可我渐渐发现，代码是才我的真爱(当然还有我的家人，朋友，和Yu)！从大四的C语言基础开始，我陆续补完了计算机本科的专业课。目前这个小站和邮箱服务就是我一点点host起来的。研究生阶段老老实实地在课堂上学完了线性代数、概率论、机器学习，推导和手撸了很多机器学习模型，以应用torch收尾。

### 技术栈：
- **Python** (pytorch, numpy, pandas)
- **后端** (LAMP)，因为上次实习的所学自考了MySQL OCP
- **略懂前端** (jQuery, html/css)
- **C/C++**
- **计算机网络基础**等
- **中英法三语**
- **计量经济学模型**(面板数据，时序分析)
- **ArcGIS**

目前在自学 Unity，希望早日当上游戏程序员

喜欢"It Just works"的畅快感； 喜欢代码不会撒谎的踏实感； 喜欢钻研一个问题不放， 最终在documentation和源码中找到归宿。

---

title: 'Unity Animation State Management with Enums'
description: "Replacing Unity Mecanim's complex state transitions with clean Enum-based character state management"
headline: 'Unity Animation State Management'
date: '2020-10-02T12:00:00'
dateUpdated: ''
published: true
author: 'Xinyu'
tags: ['unity', 'animation', 'gamedev', 'csharp']
image: '/img/blog/unity-animation.webp'
socialImage:
    src: '/img/blog/unity-animation.webp'
    mime: 'webp'
    alt: 'Unity Animation State Management'
    width: 1200
    height: 630
readTime: 8
---

Using Enums for character state management offers several advantages:

1. **Perfect replacement** for Unity Mecanim's state transition problems, avoiding the "tangled yarn ball" appearance of complex Animators
2. **[Flags] attribute** support for handling multiple simultaneous states elegantly
3. **Animation-logic decoupling** by using current state properties to drive animation changes
4. **Extensible architecture** for multi-layer animations and advanced mechanics like double-jump and coyote time

## Implementation Overview

The core concept involves replacing Unity's visual state machine with a code-based Enum system that provides better control and maintainability.

![Unity Animation State Management](https://web.archive.org/web/20210302084841im_/https://fishesplace.com/wp-content/uploads/2020/10/EnumPlayerStatus.png)

*Figure 1: MegaMan example showing simplified Animator structure compared to traditional approach*

## Core Code Implementation

```csharp
[Flags]
public enum PlayerStatus 
{
    None = 0,
    Idling = 1<<0,
    Moving = 1<<1,
    Jumping = 1<<2,
    Attacking = 1<<3,
}

private PlayerStatus currentStatus = PlayerStatus.Idling;
public PlayerStatus CurrentStatus 
{ 
    get { return currentStatus; }
    set 
    {
        if(value != currentStatus && value != PlayerStatus.None)
        {
            if(!isAbleToShoot && !value.HasFlag(PlayerStatus.Attacking)) 
                return; // maintain attack animation during cooldown
            
            UpdateAnimationState(value);
            currentStatus = value;
        }
    }
}

private void UpdateAnimationState(PlayerStatus newStatus)
{
    switch(newStatus)
    {
        case PlayerStatus.Idling:
            ChangeAnimationStateTo(PlayerIdlingAnimString);
            break;
        case PlayerStatus.Moving:
            ChangeAnimationStateTo(PlayerMovingAnimString);
            break;
        case PlayerStatus.Attacking:
            ChangeAnimationStateTo(PlayerAttackAnimString);
            break;
        case PlayerStatus.Attacking | PlayerStatus.Jumping:
            ChangeAnimationStateTo(PlayerAirAttackAnimString);
            break;
        case PlayerStatus.Jumping:
            ChangeAnimationStateTo(PlayerJumpingAnimString);
            break;
    }
}
```

## Benefits and Applications

This approach provides cleaner code organization, better debugging capabilities, and easier expansion for complex character behaviors. The bitwise operations using [Flags] attribute enable sophisticated state combinations without the complexity of traditional state machines.

---

title: 'Custom Lighting Model in ShaderLab'
description: "Creating a lighting model where object surfaces always face the observer in Unity ShaderLab"
headline: 'Observer-Facing Lighting Model'
date: '2020-08-12T12:00:00'
dateUpdated: ''
published: true
author: 'Xinyu'
tags: ['unity', 'shaders', 'shaderlab', 'lighting']
image: '/img/blog/shader-lighting.webp'
socialImage:
    src: '/img/blog/shader-lighting.webp'
    mime: 'webp'
    alt: 'Custom Lighting Model'
    width: 1200
    height: 630
readTime: 5
---

A custom lighting model that ensures object surfaces always appear to face the observer, creating unique visual effects for stylized rendering or special gameplay mechanics.

This technique is particularly useful for:
- Stylized rendering where objects should always appear bright
- UI elements that need consistent visibility
- Special effects that require observer-relative lighting
- Games with unique art styles that break traditional lighting rules

## Implementation Details

The shader modifies the normal calculation to always point toward the camera, ensuring consistent lighting regardless of the object's actual orientation or the light source position.

---

title: 'C# Events in Unity: EventHandler, Action, and UnityEvent'
description: "Understanding C# events and implementing them with EventHandler, Action, or UnityEvent in Unity"
headline: 'C# Events Implementation Guide'
date: '2020-07-02T12:00:00'
dateUpdated: ''
published: true
author: 'Xinyu'
tags: ['unity', 'csharp', 'events', 'programming', 'observer-pattern']
image: '/img/blog/csharp-events.webp'
socialImage:
    src: '/img/blog/csharp-events.webp'
    mime: 'webp'
    alt: 'C# Events in Unity'
    width: 1200
    height: 630
readTime: 7
---

Events are fundamental to game programming, enabling communication between different systems without tight coupling. Whether it's opening doors, updating UI, broadcasting messages, or coordinating NPC behavior during weather changes, events implement the Observer Design Pattern elegantly.

## Common Event Scenarios

- **Door Systems**: "I'm approaching, open up!" - "Please proceed"
- **Notifications**: WeChat messages, email alerts, bulletin boards
- **Game Mechanics**: Tower defense path updates, weather system responses
- **UI Updates**: Score changes, health modifications, inventory updates

## Implementation Approaches

### 1. EventHandler
Best for simple notifications with standard event patterns.

### 2. Action/Func
Ideal for functional programming approaches and simple callbacks.

### 3. UnityEvent
Perfect for designer-friendly configurations and Inspector-based event binding.

Each approach has its strengths depending on your specific use case and team workflow preferences.

---

title: 'Unity Learning DevLog: Rocket Boost and 3D Flight Mechanics'
description: "Week 3&4 progress in Unity learning journey covering 3D flight mechanics, lighting systems, and rocket physics"
headline: 'Unity DevLog: 3D Flight Development'
date: '2020-06-21T12:00:00'
dateUpdated: ''
published: true
author: 'Xinyu'
tags: ['unity', 'devlog', 'flight-mechanics', 'gamedev', 'learning']
image: '/img/blog/unity-devlog.webp'
socialImage:
    src: '/img/blog/unity-devlog.webp'
    mime: 'webp'
    alt: 'Unity 3D Flight Development'
    width: 1200
    height: 630
readTime: 6
---

## Week 3&4 Progress (June 2020)

### June 20th Update
First encounter with Unity's Lighting system - admittedly went overboard with the lighting effects! Improved rocket rotation and thrust mechanics by implementing proper acceleration and deceleration curves, significantly enhancing control responsiveness.

### Technical Challenges
Unity's 3D modeling capabilities proved challenging for creating complex spacecraft geometry. However, the focus remained on mastering the core flight mechanics rather than visual complexity.

### 3D Flight Mechanics Implementation

#### Rocket Boost Project
- **Thrust Physics**: Implemented realistic acceleration curves
- **Rotation Control**: Smooth rotational responses with momentum
- **Fuel Management**: Resource-based propulsion system
- **Collision Detection**: Precise landing mechanics

#### Argon Assault Project
- **Yaw Control**: Horizontal aircraft movement
- **Pitch Control**: Vertical elevation changes  
- **Roll Control**: Banking and rotation effects
- **Flight Boundaries**: Constrained movement within play area

### Key Learnings
The transition from 2D to 3D mechanics required understanding Unity's physics system in three dimensions. The most significant improvement was implementing proper physics-based movement rather than simple transform translations.

### Next Steps
Continue refining flight mechanics and explore more advanced 3D game development concepts including camera systems and level design for 3D environments.

---

title: 'Precise 2D Character Movement with Acceleration and Deceleration'
description: "Implementing smooth acceleration and deceleration curves for 2D character movement inspired by Celeste's physics"
headline: 'Smooth 2D Character Movement'
date: '2020-06-20T12:00:00'
dateUpdated: ''
published: true
author: 'Xinyu'
tags: ['unity', '2d-platformer', 'physics', 'character-movement', 'celeste']
image: '/img/blog/2d-movement.webp'
socialImage:
    src: '/img/blog/2d-movement.webp'
    mime: 'webp'
    alt: 'Smooth 2D Character Movement'
    width: 1200
    height: 630
readTime: 6
---

After extensive research and experimentation, I discovered near-perfect code for implementing precise character movement with controlled acceleration and deceleration curves, directly inspired by GMTK's analysis of Celeste's movement system.

## The Problem
Basic Unity movement often feels binary - characters instantly reach maximum speed and stop immediately. This creates unsatisfying, robotic movement that lacks the fluidity players expect from modern platformers.

## The Solution
The key is implementing proper acceleration and deceleration curves that allow fine control over:
- **Maximum speed limits**
- **Acceleration rates** when starting movement
- **Deceleration rates** when stopping
- **Smooth transitions** between movement states

## GMTK's Celeste Analysis
The yellow curve represents Celeste's optimized velocity progression, showing how the game achieves its exceptional movement feel through carefully tuned physics parameters.

## Implementation Benefits
- **Responsive Controls**: Immediate input response with gradual speed changes
- **Natural Feel**: Movement that matches player expectations
- **Customizable Parameters**: Fine-tuning options for different character types
- **"It Just Works"**: Reliable physics that doesn't fight Unity's systems

This approach transforms basic movement into something that feels polished and professional, elevating the entire gameplay experience.

---

title: 'Tile Vania: The Runner - 2D Platform Game'
description: "A fast-paced 2D runner game featuring precise platforming mechanics, online leaderboards, and polished visual effects"
headline: 'Tile Vania: The Runner'
date: '2020-06-19T12:00:00'
dateUpdated: ''
published: true
author: 'Xinyu'
tags: ['unity', 'game', '2d-platformer', 'runner', 'complete-project']
image: '/img/blog/tile-vania.webp'
socialImage:
    src: '/img/blog/tile-vania.webp'
    mime: 'webp'
    alt: 'Tile Vania: The Runner'
    width: 1200
    height: 630
readTime: 8
---

[Tile Vania: The Runner](/games/tile_vania) is a fast-paced 2D platformer where an agile protagonist embarks on a trial to prove he's the fastest runner. Challenge yourself and leave your name on the online leaderboard!

## Game Features

### Core Mechanics
- **Precise Controls**: Responsive character movement with smooth acceleration
- **Speed Focus**: Optimized for fast-paced gameplay and time trials
- **Online Leaderboard**: Compete with players worldwide
- **Challenging Levels**: Carefully designed obstacles and platforming sections

### Technical Implementation

#### Visual Effects
- **Cinemachine Integration**: Professional camera following and smoothing
- **After-image Effects**: Visual feedback for high-speed movement
- **Pixel Art Sprites**: Custom-designed character animations
- **Particle Systems**: Enhanced visual feedback for actions

#### Asset Integration
- **Unity Asset Store**: Leveraged high-quality tileset assets
- **Custom Pixel Art**: Original character sprites and animations
- **Audio Design**: Carefully selected music and sound effects
- **UI Polish**: Clean, functional interface design

### Development Insights
This project took longer than anticipated due to the focus on polish and game feel. The integration of Cinemachine for camera work and the implementation of visual effects like character after-images significantly enhanced the player experience.

### Key Learnings
- **Asset Store Integration**: Efficiently combining purchased assets with custom content
- **Game Feel**: The importance of visual and audio feedback in fast-paced games
- **Online Features**: Implementing leaderboard systems for competitive play
- **Performance Optimization**: Ensuring smooth gameplay at high speeds

### Play Now
Experience [Tile Vania: The Runner](/games/tile_vania) directly in your browser or download the Windows version for offline play.

---

title: 'Enhanced Jump Mechanics Using Unity Physics'
description: "Implementing better jump feel in 2D platformers using Unity's native physics system, inspired by Celeste's mechanics"
headline: 'Better Jump Mechanics in Unity'
date: '2020-06-17T12:00:00'
dateUpdated: ''
published: true
author: 'Xinyu'
tags: ['unity', '2d-platformer', 'jump-mechanics', 'physics', 'celeste']
image: '/img/blog/jump-mechanics.webp'
socialImage:
    src: '/img/blog/jump-mechanics.webp'
    mime: 'webp'
    alt: 'Enhanced Jump Mechanics'
    width: 1200
    height: 630
readTime: 7
---

After watching GMTK's analysis of Celeste's exceptional jump mechanics, I realized that while basic jumping can be implemented in a few lines of code, creating truly satisfying jump feel requires much more sophisticated techniques.

## The Problem with Basic Jumping
Unity's default physics system, while powerful, doesn't naturally produce the nuanced jump mechanics that players expect from modern platformers. Simple `AddForce` calls result in floaty, imprecise movement that lacks responsiveness.

## Celeste's Jump Excellence
Celeste's jump mechanics are renowned for their precision and feel. The game employs several techniques:
- **Variable jump height** based on button hold duration
- **Coyote time** for forgiving platform edges
- **Jump buffering** for responsive input handling
- **Gravity scaling** for different fall speeds

## Implementation Strategies

### 1. Variable Jump Height
Modify gravity and velocity based on input duration to allow precise height control.

### 2. Enhanced Ground Detection
Implement robust ground checking that accounts for slopes, moving platforms, and edge cases.

### 3. Input Buffering
Store jump inputs briefly to handle timing inconsistencies between player intent and execution.

### 4. Coyote Time
Allow jumping for a brief moment after leaving a platform, reducing frustration from near-miss scenarios.

## Unity Physics Considerations
While Unity's physics system can be challenging for precise platformer mechanics, proper implementation of these techniques can achieve professional-quality jump feel that rivals commercial games.

The key is understanding that great game feel comes from thoughtful design decisions rather than simply relying on default physics behavior.

---

title: 'Medical Image Generation with Conditional GANs'
description: "Deep learning course project generating high-resolution chest X-ray images from diagnostic reports using conditional GANs"
headline: 'AI-Generated Medical Imaging'
date: '2020-06-16T12:00:00'
dateUpdated: ''
published: true
author: 'Xinyu'
tags: ['deep-learning', 'gans', 'medical-imaging', 'machine-learning', 'coursework']
image: '/img/blog/medical-ai.webp'
socialImage:
    src: '/img/blog/medical-ai.webp'
    mime: 'webp'
    alt: 'Medical Image Generation'
    width: 1200
    height: 630
readTime: 6
---

## Project Overview
This deep learning course project focuses on generating high-resolution chest X-ray images from medical diagnostic reports using conditional Generative Adversarial Networks (GANs).

## Technical Approach

### Input/Output Pipeline
- **Input**: Medical diagnostic reports and X-ray descriptions
- **Output**: High-resolution (256×256) frontal and lateral chest X-ray images
- **Architecture**: Multi-layer conditional GAN structure

### Network Architecture
The system employs multiple conditional GAN layers to progressively generate higher resolution images:

1. **Text Processing Layer**: Converts diagnostic reports into feature vectors
2. **Initial Generation Layer**: Creates low-resolution base images
3. **Progressive Refinement**: Multiple upscaling layers for detail enhancement
4. **Final Output Layer**: Produces 256×256 resolution medical images

### Key Innovations
- **Conditional Generation**: Images are generated based on specific diagnostic conditions
- **Multi-Scale Architecture**: Progressive resolution enhancement for detailed results
- **Medical Domain Adaptation**: Specialized training for radiological image characteristics

## Applications and Implications

### Medical Training
- **Educational Tools**: Generate diverse case studies for medical education
- **Rare Condition Simulation**: Create examples of uncommon pathologies
- **Training Data Augmentation**: Expand datasets for other medical AI systems

### Research Potential
- **Diagnostic Algorithm Testing**: Provide controlled test cases
- **Imaging Protocol Development**: Support new scanning technique research
- **Cross-Modal Medical AI**: Bridge text and image understanding in healthcare

## Technical Challenges
- **Medical Accuracy**: Ensuring generated images maintain clinical validity
- **Ethical Considerations**: Responsible use of AI in medical contexts
- **Data Privacy**: Handling sensitive medical information appropriately

This project demonstrates the potential of AI in healthcare while highlighting the importance of ethical implementation and clinical validation.

---

title: 'Steam Game Sales Prediction with Machine Learning'
description: "Course project developing ML models to predict Steam platform game sales with deployed online prediction tool"
headline: 'Steam Sales Prediction Model'
date: '2020-06-11T12:00:00'
dateUpdated: ''
published: true
author: 'Xinyu'
tags: ['machine-learning', 'steam', 'sales-prediction', 'data-science', 'coursework']
image: '/img/blog/steam-prediction.webp'
socialImage:
    src: '/img/blog/steam-prediction.webp'
    mime: 'webp'
    alt: 'Steam Sales Prediction'
    width: 1200
    height: 630
readTime: 5
---

## Project Overview
Want to know how many copies a game might sell on Steam? Curious about which games are similar to your concept? This course project delivers a comprehensive machine learning solution for predicting Steam game sales with an online deployment for real-world testing.

## Model Features

### Prediction Capabilities
- **Sales Volume Estimation**: Predict potential copy sales based on game characteristics
- **Similar Game Discovery**: Find games with comparable market performance
- **Market Analysis**: Understand factors that influence game success
- **Genre Performance**: Analyze trends across different game categories

### Technical Implementation
- **Data Collection**: Comprehensive Steam marketplace data analysis
- **Feature Engineering**: Extraction of relevant game characteristics
- **Model Training**: Multiple ML algorithms for optimal prediction accuracy
- **Web Deployment**: Online tool for accessible predictions

## Key Insights

### Success Factors
The model identifies several critical factors that influence game sales:
- **Genre Trends**: Popular categories and emerging niches
- **Release Timing**: Seasonal patterns and market saturation
- **Price Points**: Optimal pricing strategies for different game types
- **Developer Reputation**: Impact of studio history on sales potential

### Practical Applications
- **Indie Developer Planning**: Market research for small studios
- **Investment Decisions**: Risk assessment for game funding
- **Marketing Strategy**: Understanding target audience size
- **Competitive Analysis**: Positioning against similar titles

## Online Tool
The deployed model provides real-time predictions and analysis, making market research accessible to developers, publishers, and gaming enthusiasts.

This project demonstrates the practical application of machine learning in the gaming industry, providing valuable insights for market participants.

---

title: 'Glitch Garden - Tower Defense with Complex Programming'
description: "A sophisticated tower defense game featuring modular enemy spawning, boss battles, and precise numerical design"
headline: 'Glitch Garden Tower Defense'
date: '2020-05-26T12:00:00'
dateUpdated: ''
published: true
author: 'Xinyu'
tags: ['unity', 'game', 'tower-defense', 'complete-project', 'boss-battle']
image: '/img/blog/glitch-garden.webp'
socialImage:
    src: '/img/blog/glitch-garden.webp'
    mime: 'webp'
    alt: 'Glitch Garden Tower Defense'
    width: 1200
    height: 630
readTime: 8
---

As both lead programmer and designer, I created [Glitch Garden](/games/glitch_garden), a tower defense game featuring two complete levels with an exciting boss battle finale. Build your gnome army and create an impenetrable defense line!

## Game Features

### Core Gameplay
- **Two Complete Levels**: Progressively challenging defensive scenarios
- **Epic Boss Battle**: Climactic final encounter testing all skills
- **Strategic Depth**: Multiple defender types with unique abilities
- **Resource Management**: Balanced economy system for tower placement

### Technical Innovations

#### Modular Enemy Spawning System
- **Precise Wave Design**: Mathematically balanced enemy progression
- **Flexible Configuration**: Easy level modification and balancing
- **Performance Optimization**: Efficient enemy management for smooth gameplay
- **Variety Management**: Diverse enemy types with distinct behaviors

#### Programming Architecture
- **Clean Code Structure**: Maintainable and extensible codebase
- **Component-Based Design**: Modular tower and enemy systems
- **Event-Driven Architecture**: Responsive game state management
- **Data-Driven Balance**: External configuration for game tuning

## Asset Integration

### Visual Design
- **Glitch-The-Game Assets**: High-quality art assets providing consistent visual style
- **Custom UI Elements**: Tailored interface design for optimal user experience
- **Particle Effects**: Enhanced visual feedback for combat and abilities
- **Animation Systems**: Smooth character and effect animations

### Audio Design
- **Background Music**: Atmospheric tracks supporting gameplay tension
- **Sound Effects**: Responsive audio feedback for player actions
- **Audio Balancing**: Careful mixing for optimal gameplay experience

## Development Insights

### Numerical Design Challenges
Creating balanced gameplay required extensive playtesting and mathematical analysis. The enemy-to-defender ratio, resource generation rates, and upgrade costs all needed careful calibration.

### Level Design Philosophy
Each level introduces new mechanics while building upon previous knowledge, ensuring players feel challenged but not overwhelmed.

### Boss Battle Design
The final boss encounter combines all previously learned mechanics into a climactic test of player skill and strategic thinking.

## Play Now
Experience [Glitch Garden](/games/glitch_garden) directly in your browser and see if you can build the ultimate gnome defense!